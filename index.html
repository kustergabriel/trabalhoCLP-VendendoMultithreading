<!DOCTYPE html>
<html lang="pt-Br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Elixir</title>
</head>
<body>
    <img src="imagens/logo elixir.png" alt="Logo Elixir">
    <h1>Por que você deve usar <mark>elixir</mark></h1>
    <ul>
        <li>A linguagem Elixir foi projetada para a construção de sistemas concorrentes, distribuídos e tolerantes a falhas. Baseada na máquina virtual Erlang (BEAM), herda um modelo de concorrência centrado em processos leves, isolamento completo e comunicação por troca de mensagens. Em contraste com abordagens baseadas em threads e memória compartilhada, Elixir adota o modelo de atores, no qual cada processo atua como uma unidade independente, com estado próprio e interação exclusivamente assíncrona.</li>
        <li>Essa arquitetura favorece a escalabilidade e a robustez, características centrais em aplicações como servidores web, sistemas de telecomunicações e pipelines de dados em tempo real.</li>
        <li>O Elixir é uma linguagem funcional e imutável, o que simplifica o raciocínio sobre o estado da aplicação e reduz a ocorrência de bugs em ambientes concorrentes.</li>
        <li>Possui sintaxe expressiva e amigável, inspirada no Ruby, mas com a robustez do ecossistema Erlang.</li>
    </ul>
    <h2>Porque você deve utilizar <mark>elixir</mark> para <mark>Programação Multithreading</mark> </h2>
    <ul>
        <li>Esqueça limites de 10, 100 ou 1000 threads. Com Elixir, é comum rodar milhões de processos simultaneamente em uma única máquina. Cada processo Elixir/Erlang consome apenas kilobytes de memória e é gerenciado independentemente pelo agendador da BEAM.</li>
        <li>Elixir abraça o lema "Let it crash". Em vez de tentar prever todos os erros possíveis, você constrói sistemas resilientes com supervision trees. Quando um processo falha, um supervisor reinicia automaticamente, sem comprometer o restante do sistema.</li>
        <li>Precisa escalar horizontalmente? Sem problemas. Elixir permite que diferentes nós da aplicação se comuniquem como se estivessem rodando localmente, sem a complexidade de sockets, filas ou APIs REST. É concorrência distribuída de verdade, de forma nativa.</li>
        <li>O modelo de concorrência é naturalmente distribuído, facilitando a criação de clusters de máquinas que funcionam como um único sistema coeso.</li>
        <li>As bibliotecas OTP fornecem ferramentas prontas para lidar com tolerância a falhas, comunicação entre processos e escalabilidade.</li>
        <li>Ao contrário de linguagens que usam *threads* do sistema operacional, o Elixir cria processos isolados dentro da BEAM, que são agendados cooperativamente, garantindo menor sobrecarga e melhor uso dos múltiplos núcleos de CPU.</li>
        <li>Não há memória compartilhada entre processos, eliminando problemas de *deadlock* e *race conditions* sem precisar de mecanismos complexos como *mutex* e *locks*.</li>
        <li>A comunicação é feita por envio de mensagens assíncronas, e cada processo possui sua própria fila de mensagens, o que simplifica o design de sistemas altamente concorrentes.</li>
    </ul>

    <h2>Recursos e vantagens da linguagem <mark>Elixir</mark> para programação multithread</h2>

    <ul>
      <li><strong>Isolamento de processos:</strong> Cada processo funciona de forma independente, evitando problemas comuns em multithreading como deadlocks e condições de corrida.</li>
      <li><strong>Modelo "Let it crash":</strong> Em vez de tentar prever todos os erros, Elixir permite que processos falhem e sejam reiniciados automaticamente por supervisores, aumentando a resiliência do sistema.</li>
      <li><strong>Escalabilidade natural:</strong> Os processos são distribuídos automaticamente entre os núcleos da CPU e podem ser espalhados por várias máquinas, facilitando a escalabilidade horizontal.</li>
      <li><strong>Facilidade de uso:</strong> A sintaxe clara e funcional de Elixir, inspirada no Ruby, torna a construção de sistemas concorrentes mais acessível e intuitiva.</li>
    </ul>

    <p>Para entender melhor, imagine uma grande empresa onde cada funcionário (processo) trabalha em sua própria sala (memória isolada), comunicando-se apenas por e-mails (mensagens assíncronas). Se um funcionário ficar doente (processo falhar), o gerente (supervisor) rapidamente substitui por outro, sem prejudicar o andamento geral do trabalho. Isso evita que toda a empresa pare por causa de um problema isolado.</p>

    <p>Elixir já é usado em aplicações reais e de alta demanda, como o <a href="https://www.geeksforgeeks.org/system-design/how-discord-scaled-to-15-million-users-on-one-server/">Discord</a>, que gerencia milhões de usuários simultâneos, e o <a href="https://www.quora.com/Why-was-Erlang-used-for-the-development-of-WhatsApp-What-superiority-does-Erlang-enjoys-over-other-languages">WhatsApp</a>, que suporta bilhões de conexões, comprovando a robustez e eficiência do modelo multithread baseado em processos da linguagem.</p>

    <h3>Aplicações que usam <mark>elixir</mark></h3>
    <ul>
        <li><a href="https://www.quora.com/Why-was-Erlang-used-for-the-development-of-WhatsApp-What-superiority-does-Erlang-enjoys-over-other-languages">WhatsApp: usa a VM Erlang para gerenciar bilhões de conexões simultâneas com uma equipe pequena.</a></li>
        <li><a href="https://www.geeksforgeeks.org/system-design/how-discord-scaled-to-15-million-users-on-one-server/">Discord: usa Elixir para gerenciar gateways altamente concorrentes.</a></li>
        <li><a href="https://paraxial.io/blog/elixir-savings">Pinterest: Como Elixir Economiza $2 Milhões por Ano</a></li>
        <li><a href="https://hexdocs.pm/phoenix/overview.html">Phoenix Framework: um dos frameworks web mais rápidos e escaláveis do mercado.</a></li>
    </ul>
</body>
</html>
